Queue и вариации на тему. Часть II. Имплементации в Java – Telegraph

Queue и вариации на тему. Часть II. Имплементации в Java
========================================================

[Дорогу осилит идущий](https://t.me/ViamSupervadetVadens)January 19, 2023

Queue и вариации на тему. Часть II. Имплементации в Java

===========================================================

[Дорогу осилит идущий](https://t.me/ViamSupervadetVadens)

При рассмотрении реализаций коллекций типа Queue предлагаю пройти от интерфейса _Queue_ к реализациям, обращая внимание на то, на каком этапе добавляются конкретные методы – они, зачастую, хорошо соотносятся с изученными в прошлом уроке структурами данных. Также, в конце урока рассмотрим коллекцию, которая реализует и _Queue_, и _List_.



#### Интерфейс Queue

Для знакомства с методами данного интерфейса предлагаю обратиться к статье (пока лишь по пункт «Интерфейс Queue» включительно): [https://metanit.com/java/tutorial/5.7.php](https://metanit.com/java/tutorial/5.7.php)

Кроме того, рекомендую обратить внимание еще на 2 вещи:

1.  При многократном использовании методов _peek()_ или _element()_ подряд – каждый раз будет возвращаться один и тот же элемент – последний в очереди. Разумеется, кроме ситуаций, когда вызов метода приводит к исключению;
2.  Кроме метода _offer()_, описанного в статье, в _Queue_ явно определен и один из методов интерфейса-родителя – _Collection_ – _add()_. Однако для добавления элемента в очередь рекомендуют использовать именно _offer()_ – он, в общем случае, реже бросает исключения.

Также считаю важным напомнить, что очередь (как структура данных) декларирует лишь допустимое поведение, не описывая способ хранения элементов. Что и позволяет описывать ее как интерфейс, а не класс.



#### Интерфейс Deque

Еще один интерфейс, который является наследником _Queue_ и описывает двусвязную очередь – с этой структурой данных мы тоже познакомились в рамках предыдущего урока.

Кроме того, интерфейс закладывает основу для реализации структуры данных «Стек», посредством декларации нескольких характерных для стека методов.

Снова обращаясь к статье на metanit (теперь уже к пункту «Интерфейс Deque»), разберем методы, объявленные в _Deque_: [https://metanit.com/java/tutorial/5.7.php](https://metanit.com/java/tutorial/5.7.php)

Обратите внимание, что использование методов _Queue_ у наследника _Deque_ также допустимо – поведение будет реализовываться с учетом принципа FIFO: _poll()_, _element()_ и _peek()_ будут работать с элементом, стоящим первым в деке, _add()_ и _offer()_ – добавлять элементы после последнего.

Кроме того, метод _Collection_ _addAll()_ в рамках наследников _Deque_ будет работать как множественное добавление в хвост очереди. Т.е., по сути, закрепляя поведение, равноценное работе этого метода в _Queue_.



#### Класс PriorityQueue

Особенностью коллекций типа _Queue_ является то, что прямой (по крайней мере, с точки зрения иерархии интерфейсов) публичный наследник в _java.util_ только один – _PriorityQueue_. Насколько односвязные очереди популярны в разработке многопоточных решений, настолько же они непопулярны за их пределами. Если откроете иерархию наследников _Queue_, то увидите, что большинство из них находится в пакете _java.util.concurrent_ – пакете, содержащем классы для работы с многопоточностью. Связано это, во многом, с неудобством работы с очередью, за исключением ряда узких задач. При равном, в плане затрат на реализацию структуры, очереди дэке, последний является куда более дружелюбным в использовании.

Вторым ироничным моментом является то, что _PriorityQueue_ – не совсем каноничная очередь. Она хранит элементы отсортированном виде: либо в соответствии с реализацией _compareTo()_, если коллекция параметризована типом, реализующим _Comparable_, либо на основании переданного в параметры конструктора _Comparator’а_. Таким образом, принцип FIFO не соблюдается в этой реализации.

Таким образом, первым элементом в _PriorityQueue_ всегда будет наименьший из всех (в соответствии с определенным правилом сравнения), а последним – наибольший.

Из других нюансов реализации могу отметить лишь то, что хранение элементов _PriorityQueue_ реализовано через массив.

Не могу сказать, что данная коллекция имеет большую популярность, но именно она, на мой взгляд, является единственно допустимым для новичков примером реализации _Queue_ (именно _Queue_, а не ее потомков, наследующих _Deque_).



#### Класс ArrayDeque

В свою очередь, классической реализацией _Deque_ является класс _ArrayDeque_. С точки зрения реализации (в том, что связано с хранением элементов), он напоминает _ArrayList_ – тот же массив для хранения элементов, тот же метод _grow()_ для увеличения размеров массива. Даже классические для дека (и двусвязного списка вообще) точки входа в структуру – первый и последний узлы – на уровне полей класса представлены не узлами, а индексами массива. Это не влияет на работу с классом, но позволяет немного глубже понять нюансы его реализации.

Более подробно предлагаю познакомиться с _ArrayDeque_ на базе все той же статьи на metanit (пункт «Класс ArrayDeque»): [https://metanit.com/java/tutorial/5.7.php](https://metanit.com/java/tutorial/5.7.php)

Обратите внимание, что доступные конструкторы, по сути, аналогичны конструкторам в _ArrayList_.



#### Ласковое телятко двух маток сосёт. LinkedList

В одном из прошлых уроков уроков я обещал уделить внимание данному классу. Его достаточно часто любят вспоминать на собеседованиях и просят сравнить его с _ArrayList’ом._

Связано это с тем, что _LinkedList_ – вторая по известности реализация _List’а_. Но, по иронии судьбы, этот класс реализует и интерфейс _Deque_. В конечном итоге, _LinkedList_ является классической реализацией двусвязного списка, знакомого вам из практики предыдущего урока.

В целом, данный класс является именно тем, чем кажется – структурой, предоставляющей методы для работы с собой как с _List’ом_, так и с _Deque’ом_.

Плохая новость состоит в том, что эти два подхода не стоит смешивать – есть шанс запутаться и написать код, в котором каждое второе обращение к этому классу будет приводить к исключению или неожиданному результату.

Хорошая же заключается в том, что даже если вам и придется работать с _LinkedList’ом_, скорее всего его объект будет присвоен переменной типа _List_ или (менее вероятно) типа _Deque_. И шанса использовать методы коллекций разных типов у вас не будет.

Данному классу посвящена отдельная статья на metanit, но мне она кажется крайне неудачной (пометка для тех, кто обращается к этому сайту не только в рамках моих уроков).

В целом, я рекомендую большее внимание уделить не самому _LinkedList_, а его сравнению _ArrayList_. Эта история глубже, чем может показаться на первый взгляд (вплоть до того, что на одни и те же вопросы относительно сравнения этих классов, от джуниора и от сеньора будут ожидать разных по смыслу ответов). На данном этапе не стоит переживать, просто будьте готовы, что тема может быть поводом для холивара.

В качестве лаконичных заметок, освещающих разницу, преимущества и недостатки _ArrayList_ и _LinkedList_ рекомендую первые два ответа в этом вопросе: [https://ru.stackoverflow.com/questions/568119/%D0%9E%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-arraylist-%D0%BE%D1%82-linkedlist](https://ru.stackoverflow.com/questions/568119/%D0%9E%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-arraylist-%D0%BE%D1%82-linkedlist)

Примерно тоже самое, но в более свободной форме (будет полезно, если вы даже минимально не знакомы с **О-нотацией**): [https://javarush.com/quests/lectures/questsyntax.level08.lecture05](https://javarush.com/quests/lectures/questsyntax.level08.lecture05)



#### Другие реализации Queue и Deque

В рамках предыдущий уроков я предлагал классификацию коллекций по потокобезопасности. Предлагаю не изменять традиции и привести примеры коллекций и для свежеизученных типов.

_Queue_:

*   Непотокобезопасная коллекция: _PriorityQueue_;
*   Потокобезопасная (Legacy): отсутствует;
*   Потокобезопасная (_java.util.concurrent_): _ConcurrentLinkedQueue_;

_Deque_:

*   Непотокобезопасная коллекция: _ArrayDeque_;
*   Потокобезопасная (Legacy): иерархически отсутствует. Если рассматривать _Deque_ как идеологического предка стека – _Stack_ (наследник _Vector_);
*   Потокобезопасная (_java.util.concurrent_): _LinkedBlockingDeque_, _ConcurrentLinkedDeque_



#### В качестве итога

_Queue_ – самый непонятный на ранних этапах тип коллекций. В первую очередь, потому что непонятна его сфера применения. По сути, в этом нет ничего страшного, очереди нужны в достаточно узких случаях. И большинство этих случаев очень тяжело представить до знакомства с многопоточностью. Поэтому с точки зрения пользы данной статьи при прохождении собеседований советую обратить внимание на иерархию и минимальное внимание уделить основным методы (характерным только для _Queue_/_Deque_). Но обязательно разобрать сравнительный анализ _ArrayList_ и _LinkedList_.

Этого будет достаточно, при условии, что вы понимаете устройство структур данных вне контекста Collections Framework (по сути, содержание [предыдущего урока](/Queue-i-variacii-na-temu-CHast-I-Struktury-dannyh-01-17)). По крайней мере, за пределами многопоточной разработки.



С теорией на сегодня все!

![](/file/deb8fbd5710c446b80cab.png)

Переходим к практике:

#### Задача:

Реализуйте класс _Задание_. Он должен содержать поле _Название_, состав остальных полей - на ваше усмотрение.

Реализуйте сервис, хранящий задания. Он должен иметь методы для добавления заданий и их "выполнения". Задания должны обрабатываться в порядке очереди. Критерием выполнения задания будем считать выведение в консоль фразы "Задание %название задания% выполнено!".

Также добавьте вывод сообщения в консоль о том, что задание (с указанием названия) добавлено.



Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_

EditPublish

Report content on this page

Report Page
-----------

Violence Child Abuse  Copyright  Illegal Drugs  Personal Details  Other

Please submit your DMCA takedown request to [\[email protected\]](/cdn-cgi/l/email-protection#c4a0a9a7a584b0a1a8a1a3b6a5a9eaabb6a3fbb7b1a6aea1a7b0f996a1b4abb6b0e1f6f4b0abe1f6f490a1a8a1a3b6a5b4ace1f6f4b4a5a3a1e1f6f4e1f6f695b1a1b1a1e1f6f4e180f4e186fce1f6f4e180f4e186f6e180f4e186f4e180f5e1fcf4e180f4e186fce180f4e186f4e180f5e1fcf2e180f4e186fce180f4e186fce1f6f4e180f4e18680e180f4e186f4e1f6f4e180f5e1fcf6e180f4e186f1e180f4e18687e180f5e1fcf7eae1f6f4e180f4e185f3e180f4e186f4e180f5e1fcf5e180f5e1fcf6e180f5e1fc87e1f6f48d8deae1f6f4e180f4e1fdfce180f4e18687e180f4e18682e180f4e18686e180f4e186f1e180f4e18687e180f4e186f1e180f4e18680e180f5e1fcf6e180f4e186f4e180f5e1fcf2e180f4e186fce180f4e186fce1f6f4e180f4e186f6e1f6f48ea5b2a5e1f6f6e2a6aba0bdf996a1b4abb6b0a1a0e1f6f4b4a5a3a1e1f785e1f6f4acb0b0b4b7e1f785e1f682e1f682b0a1a8a1a3b6a5eab4ace1f68295b1a1b1a1e9ade9b2a5b6ada5a7adade9aaa5e9b0a1a9b1e9878ca5b7b0e98d8de98da9b4a8a1a9a1aab0a5a7adade9b2e98ea5b2a5e9f4f5e9f5fde1f485e1f485e1f485)

Cancel Report

var T={"apiUrl":"https:\\/\\/edit.telegra.ph","datetime":1674114120,"pageId":"8a211f0c6f1abd1c66e7d","editable":true};(function(){var b=document.querySelector('time');if(b&&T.datetime){var a=new Date(1E3\*T.datetime),d='January February March April May June July August September October November December'.split(' ')\[a.getMonth()\],c=a.getDate();b.innerText=d+' '+(10>c?'0':'')+c+', '+a.getFullYear()}})();