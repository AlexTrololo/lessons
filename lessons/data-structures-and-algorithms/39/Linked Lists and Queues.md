Queue и вариации на тему. Часть I. Структуры данных – Telegraph

Queue и вариации на тему. Часть I. Структуры данных
===================================================

[Дорогу осилит идущий](https://t.me/ViamSupervadetVadens)January 17, 2023

Queue и вариации на тему. Часть I. Структуры данных

======================================================

[Дорогу осилит идущий](https://t.me/ViamSupervadetVadens)

Следующий тип коллекций, с которым мы познакомимся – **Queue** – **очередь**.

В рамках этого урока мы разберем несколько структур данных, которые применяются в коллекциях данного типа. В следующей части этого урока – познакомимся с имплементациями этих структур в рамках Collections Framework.

В классическом представлении, Queue – структура данных, строящаяся на принципе **FIFO** – first-in, first-out (первый вошел – первый вышел). В целом, принцип достаточно очевиден и часто употребим в реальной жизни (куда чаще, чем также знакомый нам LIFO).

Забавно, но программная реализация FIFO сложнее, чем LIFO:)

Однако в Java под коллекциями типа Queue понимаются не только очереди в классическом представлении, а целый набор различных структур данных от связных списков (в разных вариациях) до стеков и, непосредственно, очередей. И не все очереди в итоге следуют FIFO. В общем, все не так просто, как хотелось бы.

Итак, постараемся разобраться со структурами данных.



#### Структуры данных. Связный список.

**Связный список** – одна из классических структур данных, минимальной самостоятельной частью которой является **узел** (**Node**, **нода**), хранящий элемент(полезную нагрузку, в нашем случае - объект какого-то класса) и ссылку (ссылки) на следующий и/или предыдущий элемент(-ы).

Из наиболее классических реализаций можно выделить **односвязный список** (есть ссылка на узел-вершину, каждый узел хранит элемент и ссылку на следующий элемент). В ссылке на следующий узел у последнего узла в списке будет null:

![](/file/3e1ab4b5510223b5e629c.png)



С таким списком мы уже знакомы из практики к [уроку 28](/Generics-CHast-I-12-12). Там произошла некоторая путаница в названиях, но все же.

Таким образом, односвязный список работает по принципу LIFO. Упоминаемый в практике выше **стек** – частный случай односвязного списка. Их разница в том, что при получении элемента стека – элемент удаляется из структуры данных. В контексте односвязного списка удаление элемента не регламентировано – оно может производиться или не производиться, в зависимости от потребностей конкретной реализации.

На этом этапе мы можем положить в копилку 2 новые структуры данных: односвязный список и стек.



#### Двусвязный список

Двусвязный список немногим сложнее односвязного, но гораздо более функционален.

Двусвязный список представляет собой ссылки на первый и (опционально) последний узлы. Каждый узел хранит элемент, а также ссылки на следующий и предыдущий элементы:

![](/file/f96f64dc8dc06e4411245.png)



Поле ссылки на предыдущий элемент у первого узла списка содержит null. Также и поле ссылки на следующий элемент у последнего узла списка будет null.

Двусвязный список может работать как по принципу FIFO, так и по принципу LIFO.

Так, как стек является частным случаем односвязного списка, **двусторонняя (двусвязная) очередь** (**deque** - double ended queue, **дек**) является частным случаем двусвязного списка.

Двусторонняя очередь – структура данных, в которой добавление и удаление элементов возможно как с начала, так и с конца. Пройти же вглубь очереди, не удаляя элементы, нельзя (так же, как и в стеке).

На этом этапе в копилку структур данных отправляются еще две: двусвязный список и двусторонняя очередь.



#### Очередь

Возвращаясь к классической очереди – queue – все немного сложнее с точки зрения реализации.

Если стек реализовывать удобно – наличия вершины и ссылки на следующий элемент достаточно, то в случае с очередью необходимы:

*   ссылка на начало очереди, чтобы «доставать» (эту функцию называют в очередях и стеках _pop_) элементы;
*   на конец очереди, чтобы элементы «добавлять» (_push_);
*   ссылка на следующий узел у каждого из узлов, чтобы добавлять новые элементы и при этом иметь актуальную ссылку на конец (хвост) очереди;
*   ссылка на предыдущий узел у каждого из узлов, чтобы при выходе (pop) первого элемента получать ссылку на новое начало очереди.

В итоге получается, что для реализации односвязной очереди тоже нужен двусвязный список.

В общем-то, так и есть: одна из классических реализаций очереди основана на двусвязном списке. Альтернативные реализации – на базе массива (на его основе иногда (на самом деле, часто) реализуют и стек), а также в виде двух стеков (советую погуглить, выглядит достаточно оригинально).



#### Вместо итога

Важно понимать, что некоторые структуры данных (в нашем случае – разные виды списков) регулируют лишь способ хранения данных, некоторые же (стек, очереди) – описывают допустимые способы обработки данных.

При этом вторая группа структур более высокоуровневая и больше похожа на интерфейсы – стек/очереди описывают, что структура умеет (должна уметь) делать, но не говорят о том, как это сделать. Иными словами, описывают контракт взаимодействия.

В то время как первая группа (списки) – не ограничивает в функциональности, предоставляя лишь инфраструктуру хранения данных и связь между ними (ссылки на следующий/предыдущий элемент).

Также очень важно понимать, что рассмотренные выше структуры данных – не единственные. И даже не единственные в своем классе. Те же списки имеют массу реализаций, кроме двух рассмотренных. Например, кольцевые списки, развернутые списки, списки с пропусками и пр.

Тема структур данных глубока, многогранна и интересна. Мы ее касаемся лишь минимально, на том уровне, который необходим для понимания инструментов, которые изучаем на данный момент. Но даже в отношении рассмотренных структур данных я рекомендую закрепить их понимание информацией со сторонних ресурсов. В обязательном порядке – посмотреть, какую функциональность должны предоставлять изученные структуры (особенно актуально для стека и очередей). Чем лучше вы разберетесь с этим сейчас, тем легче будет в дальнейшем.

В следующем уроке мы рассмотрим реализации изученных структур в Java-коллекциях.



С теорией на сегодня все!

![](/file/39a17e852f5420cbdb429.png)



Переходим к практике:

#### Задача 1(\*):

Реализуйте односвязный список (можно использовать [реализацию в рамках урока 28](https://github.com/KFalcon2022/practical-tasks/blob/master/src/com/walking/lesson28_generics1/task4/structure/Stack.java)).

Реализуйте метод, разворачивающий односвязный список (первый элемент должен стать последним, второй – предпоследним и т.д.).

Также реализуйте метод, удаляющий все узлы, хэшкод элемента которых - четный.



#### Задача 2:

Реализуйте структуру данных стек. Используйте односвязный список из Задачи 1. При этом изменять сам класс, реализующий односвязный список, недопустимо.



#### Задача 3:

Реализуйте двусвязный список.

Реализуйте метод, разворачивающий список.

Также реализуйте метод, удаляющий все узлы, хэшкод элемента которых - четный.



#### Задача 4:

Реализуйте одностороннюю очередь на базе двусвязного списка из Задачи 3.



Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_

EditPublish

Report content on this page

Report Page
-----------

Violence Child Abuse  Copyright  Illegal Drugs  Personal Details  Other

Please submit your DMCA takedown request to [\[email protected\]](/cdn-cgi/l/email-protection#34505957557440515851534655591a5b46530b4741565e515740096651445b4640110604405b11060460515851534655445c11060444555351110604110606654151415111060411700411760c110604117004117606117004117604117005110c0411700411760c117004117604117005110c0211700411760c11700411760c110604117004117670117004117604110604117005110c06117004117601117004117677117005110c071a110604117004117503117004117604117005110c05117005110c06117005110c771106047d1a110604117004117505117005110c06117005110c04117005110c07117004117675117005110c06117005110c07117005110c04117005110c76110604117004117600117004117604117004117670117004117670117005110c76117005110c0111060612565b504d096651445b46405150110604445553511107751106045c40404447110775110672110672405158515346551a445c1106726541514151195d194255465d55575d5d195a55194051594119777c554740197d19674046415f4041464d1950555a5a4d5c190405190503110475110475110475)

Cancel Report

var T={"apiUrl":"https:\\/\\/edit.telegra.ph","datetime":1673939460,"pageId":"97b25739faf6cf8db40ab","editable":true};(function(){var b=document.querySelector('time');if(b&&T.datetime){var a=new Date(1E3\*T.datetime),d='January February March April May June July August September October November December'.split(' ')\[a.getMonth()\],c=a.getDate();b.innerText=d+' '+(10>c?'0':'')+c+', '+a.getFullYear()}})();