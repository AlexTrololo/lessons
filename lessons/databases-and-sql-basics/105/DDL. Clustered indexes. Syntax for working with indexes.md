DDL. Кластеризованные индексы. Синтаксис для работы с индексами – Telegraph

DDL. Кластеризованные индексы. Синтаксис для работы с индексами
===============================================================

[Дорогу осилит идущий](https://t.me/ViamSupervadetVadens)September 02, 2023

DDL. Кластеризованные индексы. Синтаксис для работы с индексами

==================================================================

[Дорогу осилит идущий](https://t.me/ViamSupervadetVadens)

### Кластеризованные индексы

Сегодня вернемся к тебе индексов. Начнем с классификации, которую в прошлый раз упустили - **кластеризованные** и **некластеризованные** индексы.

Как говорилось в предыдущем уроке, индекс представляет собой структуру данных, которая содержит в себе ссылки на конкретные записи таблиц. Собственно, это справедливо для обычных индексов - их также можно назвать не кластеризованными в данной классификации.

Однако в некоторых СУБД (но не в PostgreSQL) существует и другой тип - кластеризованные. В целом, можно было бы опустить эту тему, если бы не любовь к ней на собеседованиях.

Итак. Кластеризованный индекс характеризуется тем, что он не является отдельной от таблицы структурой - данный индекс “хранится” вместе с таблицей и определяет порядок, в котором хранятся сами записи в рамках таблицы.  

Таким образом, при использовании кластеризованного индекса можно утверждать, что записи в таблице хранятся в отсортированном виде - на основании колонок или выражений, заданных таким индексом.

> **!NB**: Это вовсе не означает, что в выборке без указания сортировки будет применен этот же порядок. Лишь указывает на то, что фильтрация и сортировка по ключу индекса будет быстрее.

Исходя из того, что кластеризованный индекс определяет порядок записей в таблице, несложно догадаться, что такой индекс может быть всего один на таблицу.

Как правило, кластеризованные индексы строятся на базе B-tree (по крайней мере, я не знаю альтернативных примеров). 

И, наконец, немного об использовании. 

В общем-то, кластеризованный индекс обладает теми же рекомендациями по определению колонок, что и любой другой B-tree индекс. Но есть нюанс. Обычно индексы призваны ускорить поиск по таблице, что характерно и для кластеризованного индекса. Но поиск - это не только про WHERE-условия, но еще и про _JOIN_. А _JOIN_, в свою очередь, чаще всего происходит по Primary Key. В силу этого исторически сложилась популярность кластеризованного индекса по PK. 

В целом, нельзя сказать, что кластеризованный индекс является необходимым атрибутом таблицы - PostgreSQL, не имеющий такого механизма тому доказательство. Однако у такого индекса есть как минимум один плюс: он не требует дискового пространства для своего хранения:)



### Синтаксис работы с индексами

Теперь предлагаю перейти к самой простой части в теме индексов - синтаксису. Как и в других случаях, будем опираться на PostgreSQL. В случае с индексами это особенно актуально - спецификация SQL вообще не оперирует понятием индекса. Поэтому хоть общий синтаксис их использования в различных СУБД и похож (читай, продиктован духом DDL), общего регламента для синтаксиса нет.

Итак, рассмотрим простейший пример запроса для создания составного индекса:

create index i\_name on t1 (a, b);

В данном случае мы создали индекс с именем _i\_name_ на основании колонок _a_ и _b_ таблицы _t1_. Полагаю, очевидно, что колонки и выражения указываются в скобках через запятую. Соответственно, если бы нам потребовался не составной индекс - в скобках была бы указано одна колонка (или выражение).

К слову, пример создания индекса на базе выражения - для более удобного поиска по _LIKE_ для фамилии пассажира:

create index i\_passenger\_last\_name\_lower
on passenger (lower(last\_name));

Советую давать индексам осмысленные имена, которые позволяют определить таблицу, колонки и нюансы конкретного индекса - это облегчит дальнейшую поддержку.

Возможно, вы уже задались вопросом, какой тип индекса будет использован - ведь мы уже познакомились с _BTREE_, _HASH_, _GIN_ и другими.

Собственно, данный синтаксис создает индекс с типом по умолчанию - _BTREE_. Если мы хотим указать тип индекса явно - мы должны добавить предложение **_USING_**:

create index i\_passenger\_last\_purchase\_hash
on passenger using hash (last\_purchase);

Кроме этого существуют и некоторые другие предложения запроса, которые можно использовать при создании индекса (например, _WHERE_ для указания условий **частичного индекса**). Но, на мой взгляд, это не актуально на данном этапе (и вообще не актуально для основной массы разработчиков).

Также для индексов существуют и опции с оператором _ALTER_. Правда, на данном этапе нам актуально только переименование индекса, что не является частой операцией. Но хорошая новость в том, что основные опции _ALTER_ по отношению к индексу разработчику бывают нужны еще реже.

Итак, переименование:

alter index i\_passenger\_last\_purchase\_hash
rename to ix\_passenger\_last\_purchase\_hash;

Как видите, общая структура запросов в рамках DDL мало меняется от того, с каким структурным элементом мы работаем в данный момент.

И, наконец, удаление индекса:

drop index ix\_passenger\_last\_purchase\_hash;

Здесь тоже без сюрпризов.



### Вместо заключения

Индексы - крайне обширная тема, которой можно посвятить отдельный полноценный курс. В рамках текущего курса мы лишь знакомимся с основными терминами и концепцией индексов. Это более, чем достаточно для джуниоров (и, пожалуй, мидлов). Но, вероятно, настанет момент, когда вам придется углубиться в эту тему, выйдя за пределы курса. Хорошая новость заключается в том, что к этому моменту вы, вероятно, будете иметь более обширную теоретическую базу, чем сейчас, а также практический опыт, который кратно облегчит дальнейшее погружение в тему.



С теорией на сегодня все!

![](/file/1fb28642f8f9a285ea53c.png)

Переходим к практике:

### Задача

Проанализируйте SELECT-запросы, представленные в практике к предыдущим урокам. Добавьте индексы на колонки, которые наиболее часто использовались для фильтрации и сортировки данных.

Везде ли типом индекса стоит выбрать _BTREE_? Требуются ли составные индексы в рамках этой задачи?



Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/ViamSupervadetVadens](https://t.me/ViamSupervadetVadens)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_

EditPublish

Report content on this page

Report Page
-----------

Violence Child Abuse  Copyright  Illegal Drugs  Personal Details  Other

Please submit your DMCA takedown request to [\[email protected\]](/cdn-cgi/l/email-protection#76121b15173602131a131104171b58190411490503141c1315024b241306190402534446021953444622131a13110417061e5344460617111353444653444432323a58534446533246534f37533246533434533246533446533247534e47533247534e44533246533443533247534e4653324653344e533246533441533246533433533246533444533246533446533246533432533246533432533247534e3453324653344353444653324653344e533246533432533246533442533246533443533246533437533247534e47533247534e345853444653324653374753324653344e533246533432533247534e44533246533446533246533437533247534e4753324653344e533247534e47534446533246533442533246533434533247534e30534446533247534e46533246533446533246533447533246533433533247534e44533247534e34534446533247534e4753444653324653344e533246533432533246533442533246533443533246533437533247534e4753324653344653324653343553324653344e534444501419120f4b2413061904021312534446061711135345375344461e0202060553453753443053443002131a1311041758061e53443032323a5b3d1a17050213041f0c19001718180f135b1f1812131d050f5b251f1802171d051f055b121a0f175b04171419020f5b055b1f1812131d05171b1f5b464f5b4644534637534637534637)

Cancel Report

var T={"apiUrl":"https:\\/\\/edit.telegra.ph","datetime":1693696585,"pageId":"af1d63627297545f3a385","editable":true};(function(){var b=document.querySelector('time');if(b&&T.datetime){var a=new Date(1E3\*T.datetime),d='January February March April May June July August September October November December'.split(' ')\[a.getMonth()\],c=a.getDate();b.innerText=d+' '+(10>c?'0':'')+c+', '+a.getFullYear()}})();