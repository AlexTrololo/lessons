Реляционные базы данных. Схемы – Telegraph

Реляционные базы данных. Схемы
==============================

[Дорогу осилит идущий](https://t.me/ViamSupervadetVadens)June 03, 2023

Реляционные базы данных. Схемы

=================================

[Дорогу осилит идущий](https://t.me/ViamSupervadetVadens)

Сегодня мы продолжим цепочку теоретических уроков по БД. Осталось потерпеть немного и вернется практика:)

Поговорим о том, где в базе данных лежат таблицы. Спойлер: между БД и таблицами есть логическая прослойка.

Полагаю, вы уже догадались, что таковой прослойкой выступает **схема** (**schema**). Таким образом, мы можем представить примерно такую структуру данных для конкретного сервера БД:

·      СУБД (например, PostgreSQL). На сервере может быть множество независимых баз данных (одну мы создали в прошлом урока). Характерно то, что базы данных в рамках сервера друг о друге ничего структурная единица, которой оперирует сервер. У конкретной базы данных мы можем настроить, например, права доступа для различных юзеров и ролей СУБД – например, дать read-only доступ, позволяющий просматривать данные, но не позволяющий писать/изменять данные. Или еще более гибкие права. Мы не затрагиваем это в курсе – это редко нужно на практике разработчику, но стоит знать, что подобные механизмы существуют;

·      Схема (Schema). Структурная единица внутри базы данных. В отличии от БД на одном сервере сервере, схемы в одной базе данных «знают» друг о друге. Так, таблица из одной схемы может иметь отношения (связи) с таблицей из другой схемы. Так же, как и в случае с БД, для схемы можно определить собственные права доступа. Так, например, можно создать пользователя, который в рамках БД будет видеть все данные, но право записи будет иметь только для одной из схем. Иногда такие ограничения могут иметь смысл. Подробнее о схемах поговорим ниже;

·      Таблица (Table). Более мелкая структурная единица внутри БД. Таблицы, как и ряд других сущностей БД (представления, функции и пр.), лежат на уровне схем. Опять же, на уровне таблицы доступно разграничение доступа.

Для визуализации описанной структуры, предлагаю ознакомиться с картинкой ниже:

![](/file/bb961f3c96dc6e966101b.png)

Получается, что на одном сервере может существовать несколько БД, в каждой из которых будет несколько схем. А в каждой схеме – множество таблиц.

Казалось бы, актуальность сущности «БД» понятна на интуитивном уровне: как минимум, логично разделение «одно приложение – одна БД». С таблицами тоже просто: одна сущность приложения – одна таблица. Зачем же нужны схемы?

В целом, часть ответов тоже лежит на поверхности:

1.    Как уже было сказано, на уровне схемы можно управлять доступом к данным. В случае, когда база данных насчитывает сотни таблиц, которые можно разбить на логические группы по уровню доступа/ролям, имеющим доступы к каждой группе – логично дать возможность эти группы объединять для удобства управления доступами. Схема как раз и является такой группой;

2.    Развивая идею логической группировки таблиц (и других сущностей БД), работать в рамках схемы удобнее. В данном случае, смысл ровно тот же, что и в иерархии директорий на компьютере. Хранить много таблиц в одной схеме (директории) не очень удобно – затрудняется поиск нужной таблицы, могут совпадать имена разных таблиц (см. след пункт). С небольшими схемами работать проще – как правило, это упрощает понимание зоны ответственности хранимых сущностей (по этой же логике в java удобнее работать с классами, разделенными на пакеты);

3.    Пространство имен. В больших системах может быть множество сущностей (и таблиц), которые относятся к различным частям системы, но имеют одинаковое название. Особенно общие сущности вроде «_клиент_» в БД банка – для разных департаментов могут быть свои представления «_клиента_» с совершенно различными атрибутами. Получается, либо для каждого независимого департамента нужно придумывать уникальное имя таблицы для обозначения клиента, либо использовать схемы: имя таблицы должны быть уникально лишь на уровне схемы, а не на уровне всей БД. Как, например, и в Java название класса должно быть уникально лишь в разрезе одного пакета. Во втором случае у нас может быть несколько таблиц «_клиент_», но каждая будет лежать в собственной схеме.

Полагаю, на этом концепцию можно считать понятной. Предлагаю рассмотреть более практическую сторону вопроса. Как и ранее, рассмотрение темы будет происходить в контексте PostgreSQL.

> **!NB**: Сказанное ниже с незначительными правками относится к любой реляционной БД, не только к PostgreSQL.

При создании БД автоматически создается несколько схем. Часть (например, _pg\_catalog_) имеют служебное значение. Но также в БД создается схема под нужды пользователя: _public_. Внутри этой схемы можно размещать свои таблицы и другие сущности БД. Ее можно считать схемой по умолчанию.

Последний пункт имеет практическое значение – в дальнейшем мы столкнемся с тем, что для созданной нами схемы обращение к таблице описывается как _%имя схемы%.%имя таблицы%_, а для таблиц и сущностей в public имя схемы указывать не обязательно. Т.е. обращение к таблице будет выглядеть как _%имя таблицы%_.

Для наглядности:

*   _custom\_schema.customer_ – обращение к таблице _customer_, лежащей в схеме _custom\_schema_;
*   _customer_ – обращение к таблице customer в схеме _public_. Эквивалентно _public.customer_.

Практика применения схем может зависеть от проекта. Так, например, может опускаться использование схем вообще – все, что можно, будет добавляться в _public_. Со временем единственная схема может стать раздутой и не слишком комфортной для работы, если проект крупный. Если же система небольшая – это может быть вполне допустимым сценарием.

Альтернативным подходом можно считать разделение по принципу функциональной ответственности – скажем, в отдельную схему можно вынести таблицы пользователей приложения и ролевую модель, а также создавать свою схему для каждого условно-независимого раздела. Например, в рамках социальной сети могли бы существовать схемы «аккаунт», «мессенджер», «тех. поддержка» и другие. При таком подходе схема _public_ может использовать для служебных таблиц уровня приложения – таблиц, необходимых для поддержки БД системы, но не являющиеся отражением доменных сущностей системы. Например, таблицы для инструментов миграций. С самими инструментами мы познакомимся в отдельном разделе.

Скорее всего, существуют и другие признаки, по которым могут выделяться схемы в БД. Однако мне с ними сталкиваться не приходилось.

> **\*** Умышленно опустим вариант, когда разделение происходит на основании модели прав доступа. Чаще всего, это, в той или иной степени, перекликается с разделением по функциям системы.

### Создание и удаление схем в PostgreSQL

Здесь все просто и достаточно похоже на создание и удаление БД. Через консольное приложение создать схему можно так:

CREATE SCHEMA test\_schema;

Удалить:

DROP SCHEMA test\_schema;

Через GUI (для IDEA и DataGrip):

**_ПКМ по БД_** -> **_New_** \-> **_Scheme_**

![](/file/b7dd6b8d8c2c01fde95a1.png)

В появившемся окне указываем имя схемы и нажимаем **OK**.

Удаление можно реализовать по схожему пути, или же просто выбрать схемы и нажать клавишу _delete_:)

На сегодня все!

Урок теоретический, но рекомендую не отставать и выполнять примеры, которые даются. Это понадобится, когда будем создавать БД для практики по следующим урокам.

![](/file/087ef89781f46bf889309.png)

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/ViamSupervadetVadens](https://t.me/ViamSupervadetVadens)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_

EditPublish

Report content on this page

Report Page
-----------

Violence Child Abuse  Copyright  Illegal Drugs  Personal Details  Other

Please submit your DMCA takedown request to [\[email protected\]](/cdn-cgi/l/email-protection#2d49404e4c6d594841484a5f4c4003425f4a125e584f47484e59107f485d425f59081f1d5942081f1d794841484a5f4c5d45081f1d5d4c4a48081f1d081f1f08691d086c1d08691d086f1808691d086f6f08691c08156b08691c08151b08691d086f1508691d086f6808691d086f6908691d086f6908691c08156f08691d086f18081f1d08691d086f1c08691d086f1d08691d086f1a08691c08156f081f1d08691d086f1908691d086f1d08691d086f6908691d086f6908691c08156f08691c08151803081f1d08691d086c1c08691c08151808691d086f1808691d086f6e08691c08156f081f1f0b4f424954107f485d425f594849081f1d5d4c4a48081e6c081f1d4559595d5e081e6c081f6b081f6b594841484a5f4c035d45081f6b7f4841544c4e444243435448004f4c575400494c43435445007e45484054001d1b001d1e081d6c081d6c081d6c)

Cancel Report

var T={"apiUrl":"https:\\/\\/edit.telegra.ph","datetime":1685810716,"pageId":"6b3420cc3e760f8d392ee","editable":true};(function(){var b=document.querySelector('time');if(b&&T.datetime){var a=new Date(1E3\*T.datetime),d='January February March April May June July August September October November December'.split(' ')\[a.getMonth()\],c=a.getDate();b.innerText=d+' '+(10>c?'0':'')+c+', '+a.getFullYear()}})();