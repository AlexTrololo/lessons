DML. Команда SELECT – Telegraph

DML. Команда SELECT
===================

[Дорогу осилит идущий](https://t.me/ViamSupervadetVadens)July 08, 2023

DML. Команда SELECT

======================

[Дорогу осилит идущий](https://t.me/ViamSupervadetVadens)

Сегодняшняя статья (а более глобально – минимум, пять ближайших статей) будет посвящен тому, какие инструменты SQL предлагает для чтения данных из таблиц, их фильтрации, сортировки, группировки и объединения.

Непосредственно в этом уроке мы разберем синтаксис оператора, позволяющего «выбрать» что-то «откуда-то». Нюансы с фильтрациями и сортировками оставим для будущих статей.

Итак, уже, полагаю, понятно, что оператор для получения выборки называется «**_SELECT_**». Он позволяет получить указанный в запросе литерал или результат указанного в запросе выражения (результаты выборки представлены для консольного клиента, чтобы не загромождать статью скриншотами):

**Пример 1**:

select 1;

Результат:

?column?
----------
1
(1 row)



**Пример 2**:

select 2 \* 2;

Результат:

?column?
----------
4
(1 row)



**Пример 3**:

select 2 \* 2 as result;

Результат:

result
----------
4
(1 row)



**Пример 4**:

select 2 \* 2 product, 2 + 2 as sum;

Результат:

product | sum
---------+-----
4 |  4
(1 row)



Кроме того, мы можем получать информацию из таблицы:

**Пример 5**:

select \* from passenger;

Результат:

id | first\_name | last\_name | birth\_date | male |      last\_purchase       | favorite\_airports
----+------------+-----------+------------+------+----------------------------+-------------------
 1 | Ivan      | Ivanov   | 1990-07-02 | t   |                           |
 2 | Petr      | Petrov   | 1991-07-02 | t   | 2023-07-02 20:32:00       | {Minsk,Kyiv}
3 | Anna      | Annina   | 1993-07-02 | f   |                           |
 4 | Anna      | Annina   | 1993-07-02 | t   | 2023-07-02 20:44:18.086893 |
(4 rows)

Отображение оставляет желать лучшего, но таковы суровые реалии жизни консольщиков. При использовании графического интерфейса все намного удобнее:

![](/file/c9f678918b52c12d44884.png)



**Пример 6**:

select id, birth\_date from passenger;

Результат:

id | birth\_date
----+------------
  1 | 1990-07-02
  2 | 1991-07-02
  3 | 1993-07-02
  4 | 1993-07-02
(4 rows)

Кроме того, при использовании _SELECT_ доступно использование различных **функций**, как предоставляемых СУБД, так и самописных (о них – сильно позже):



**Пример 7**:

select id, concat(first\_name, ' ', last\_name) as name from passenger;

Результат:

id |   name
----+-------------
  1 | Ivan Ivanov
  2 | Petr Petrov
  3 | Anna Annina
  4 | Anna Annina
(4 rows)



Предлагаю разобрать каждый из примеров выше.



#### select 1;

Полагаю, достаточно очевидный запрос: мы пытаемся получить единицу, ее и получаем.

#### select 2 \* 2;

Здесь немного сложнее. Мы запрашиваем «_2×2_» и получаем результат этого выражения. Достаточно понятно интуитивно, но подчеркну: выражения после _SELECT_ выполняются. Вызов функции тоже считается выражением

#### select 2 \* 2 as result;

Отличие от предыдущего запроса заключается в том, что мы предоставляем «**псевдоним**» (**алиас**, alias) для результата выражения. Точнее, даем название колонки в результирующей таблице (результатом _SELECT_ всегда является таблица). В ряде случаев, например, когда мы получаем данные из таблицы, колонка может именоваться автоматически. Но когда колонка состоит из результатов выражений, имя колонки может определяться как «_?column?_» или как названием вызванной функции (уберите «_as name_» в последнем примере и запустите запрос).

Так или иначе, зачастую необходимо корректное название для колонки. Это может понадобится как при интерпретации результатов запроса в коде приложения (например, чтобы превратить (**смаппить**, от _to map_ – отображать) полученные записи в Java-объекты), так и в рамках самого SQL, если необходимо обрабатывать результаты запроса (например, в другом запросе).

Кроме того, остается и информационная функция названия – очевидно, что осознанное имя дает больше информации, чем сгенерированное SQL (за исключением выборки из одной таблицы без каких-либо преобразований данных).

Итак, оператор _AS_ позволяет присвоить колонке псевдоним, который мы считаем нужным. Помните, что слова в SQL принято разбивать символом «\_», а регистр не играет значения.

Также стоит отметить, что в postgres _AS_ не является обязательным оператором для указания псевдонима колонки в _SELECT_**\***, т.е. его можно опустить. Использовать его на практике или нет – дело ваше. На мой взгляд, он может быть удобен, если описание колонки представляет собой сложное выражение, чтобы подчеркнуть границы этого выражения. В остальных случаях я предпочитаю его опускать. Так, наш пример можно упростить до:

select 2 \* 2 result;

> **\*** У оператора **AS** есть и другие области применения, где использовать его обязательно.

#### select 2 \* 2 as product, 2 + 2 as sum;

В целом, пример похож на предыдущий, но его результатом является таблица с двумя колонками (произведением и суммой). Таким образом, число колонок в результирующей таблице определяется числом выражений, разделенных между собой запятой. На самом деле, это не всегда верно и колонок может быть больше, чем «_число запятых + 1_» сразу по нескольким причинам. Но можете быть уверены: в результирующей таблице колонок будет НЕ МЕНЕЕ, чем «_число запятых + 1_».

#### select \* from passenger;

Теперь переходим к основному назначению _SELECT_ – получению данных «откуда-то».

Источником данных может выступать таблица, представление (мы с ними еще познакомимся), другой запрос и т.д. Так или иначе, для обращения к источнику данных необходимо использовать оператор «**_FROM_**».

«**_\*_**» в данном случае означает, что мы запрашиваем все колонки из источника в их естественном порядке.

Таким образом, данный запрос можно интерпретировать как «_ВЫБРАТЬ (_**_select_**_) данные по ВСЕМ (_**_\*_**_) колонкам ИЗ (_**_from_**_) таблицы ПАССАЖИРЫ (_**_passenger_**_)_».

#### select id, birth\_date from passenger;

Данный запрос похож на предыдущий, но делает выборку не по всем колонкам, а только по указанным.

В целом, использование \* – достаточно спорная идея по ряду концептуальных и технических причин. Но это более лаконично и удобно на первых этапах. А также в ряде рутинных операций в дальнейшем.

Так или иначе, мы может выбирать из таблиц конкретные колонки, также можем указать порядок следования колонок (не обязательно тот, который представлен в таблице) или даже сделать выборку одной и той же колонки несколько раз в рамках запроса:

select birth\_date, id, id from passenger;

И, как и в запросах выше, мы можем давать колонкам свои псевдонимы, используя _AS_ или опуская его.

#### select id, concat(first\_name, ' ', last\_name) as name from passenger;

Данный пример демонстрирует работу функции конкатенации для строк, склеивая для каждой из выбранных записей (строк таблицы) значение _first\_name_, литерала « » (пробел) и _last\_name_. Таким образом, в выборку попадают не обособленные колонки, а объединенное имя пассажира. Также самой колонке присваивается псевдоним «name». Имя по умолчанию было бы «_concat_» – по названию использованной функции.

> Обратите внимание, что оператор «_+_» в SQL не предназначен для конкатенации строк (в отличии от Java).

С теорией на сегодня все!

Уже в следующем уроке мы познакомимся с инструментом, позволяющим фильтровать записи при выборке из таблиц, получая лишь те, которые подходят по заданные критерии. Пока же рекомендую освоить функциональность самого _SELECT_.

![](/file/337933d56a9a1aa9e81d8.png)

Переходим к практике:

### Задача 1

Получите список имен, фамилий и дат рождений всех пассажиров.

### Задача 2

Получите список любимых аэропортов по каждому пассажиру.

### Задача 3

Получите первый из любимых аэропортов по каждому пассажиру.

Массивы в SQL нумеруются с 1. Синтаксис для получения элементов массива не отличается от Java



Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/ViamSupervadetVadens](https://t.me/ViamSupervadetVadens)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_

EditPublish

Report content on this page

Report Page
-----------

Violence Child Abuse  Copyright  Illegal Drugs  Personal Details  Other

Please submit your DMCA takedown request to [\[email protected\]](/cdn-cgi/l/email-protection#8eeae3edefcefaebe2ebe9fcefe3a0e1fce9b1fdfbece4ebedfab3dcebfee1fcfaabbcbefae1abbcbedaebe2ebe9fceffee6abbcbefeefe9ebabbcbeabbcbccac3c2a0abbcbeabcabeabb7cfabcabeabcccbabcabeabcccdabcabeabccbeabcabeabcccaabcabeabccbaabcabeabccbeabbcbeddcbc2cbcddaabbcbca8ece1eaf7b3dcebfee1fcfaebeaabbcbefeefe9ebabbdcfabbcbee6fafafefdabbdcfabbcc8abbcc8faebe2ebe9fcefa0fee6abbcc8cac3c2a3c5e1e3efe0eaefa3ddcbc2cbcddaa3beb9a3beb6abbecfabbecfabbecf)

Cancel Report

var T={"apiUrl":"https:\\/\\/edit.telegra.ph","datetime":1688824339,"pageId":"67e39903553181509c7f0","editable":true};(function(){var b=document.querySelector('time');if(b&&T.datetime){var a=new Date(1E3\*T.datetime),d='January February March April May June July August September October November December'.split(' ')\[a.getMonth()\],c=a.getDate();b.innerText=d+' '+(10>c?'0':'')+c+', '+a.getFullYear()}})();