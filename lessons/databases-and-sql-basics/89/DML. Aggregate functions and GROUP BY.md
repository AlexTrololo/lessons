DML. Агрегатные функции и GROUP BY – Telegraph

DML. Агрегатные функции и GROUP BY
==================================

[Дорогу осилит идущий](https://t.me/ViamSupervadetVadens)July 16, 2023

DML. Агрегатные функции и GROUP BY

=====================================

[Дорогу осилит идущий](https://t.me/ViamSupervadetVadens)

На данном этапе у нас уже есть хороший набор знаний для поиска данных в реляционных БД. Но до этого момента мы работали только с исходными записями, помещенными в таблицу.

На практике же зачастую требуется не только получать данные, которые хранятся в таблицах, но и собирать некую статистику по ним.

Описанные задачи решаются с помощью агрегации данных. В данном случае имеется ввиду получение некого результата на основании агрегации записей, входящих в выборку.

PostgreSQL (как и любая другая реляционная СУБД) предоставляет ряд **агрегатных функций**. Они достаточно разнообразны, но мы рассмотрим только несколько наиболее популярных и востребованных в типовых задачах.

Для большей наглядности предлагаю начать с пары примеров:

select count(\*) from passenger;

Данный запрос вернет таблицу с единственной ячейкой. В ней будет содержаться число записей в таблице passenger.

select count(\*) from passenger where male = true;

Данный запрос вернет число мужчин в таблице. Таким образом, сначала запрос сделает выборку по _WHERE_, а лишь потом – произведет агрегацию данных.

Также стоит отметить, что «_\*_», в данном случае, не относится к _SELECT_, она, скорее, является специфическим параметром функции. Альтернативу рассмотрим ниже.

Теперь предлагаю ознакомиться с наиболее популярными агрегатными функциями:

·      **_count(\*)_**.  Как уже было сказано выше – производит подсчет строк, попавших в выборку;

·      **_count(_**_выражение_**_)_**. Модификация _count(\*)_ с дополнительной фильтрацией на null. Под выражением, как обычно, может подразумеваться колонка таблицы, вызов функции и т.д:

select count(last\_purchase) from passenger;

По сути, _выражение_ можно рассматривать как дополнительное WHERE-условие вида «**_выражение_** _is not null_». В целом, для улучшения производительности рекомендую использовать явное WHERE-условие, вместо параметра _count()_, если это возможно;

·      **_avg(_**_выражение_**_)_**. Для выражения с числовым результатом возвращает среднее значение результата. Если выражение состоит из одной колонки (как в примере выше) – возьмет из выборки все значения в этой колонке и посчитает их среднее значение. NULL-значения будут проигнорированы – т.е. не просто приняты за 0 (нуль), а полностью исключены из расчета;

·      **_sum(_**_выражение_**_)_**. Считает сумму значений. Все остальное – как и в функции выше;

·      **_min(_**_выражение_**_)_** и **_max(_**_выражение_**_)_**. Находит меньшее и большее значения в выборке для заданного выражения. Опять же, кроме _NULL_.

С более подробным описанием и другими агрегатными функциями можно познакомиться по ссылке ниже. Рекомендую пока ограничиться первой таблицей: [https://postgrespro.ru/docs/postgrespro/10/functions-aggregate](https://postgrespro.ru/docs/postgrespro/10/functions-aggregate)

### Оператор GROUP BY

Вы могли заметить, что любая агрегатная функция в примерах выше всегда возвращала одну строку – функция применялась для всей выборки целиком: считала число всех элементов в выборке, среднее всех элементов и выборке и т.д.

Гораздо чаще в практических задачах приходится получать данные агрегации, сгруппированные по каким-то критериям. Можно, конечно, сделать больше запросов, каждый раз отсекая все группы, кроме интересующей нас, но это не эффективно.

Итак, группировка:

select count(\*), male from passenger group by male;

Данный запрос возвращает две строки (да и в таблице уже 2 столбца): число женщин и число мужчин.

Таким образом, в рамках запроса была получена выборка (_WHERE_ нет => вся таблица), разбита на части по совпадающим значениям поля _male_ (_group by male_) и далее была произведена агрегация для каждой из полученных групп: _male = false_ и _male = true_ соответственно.

Как и в случае с _ORDER BY_, нам нет необходимости включать в _SELECT_ те же колонки, что и в _GROUP BY_:

select count(\*) from passenger group by male;

Другой вопрос, что информативность такого запроса будет нулевой.

Однако ВСЕ колонки, которые указаны в _SELECT_, за исключением переданных параметром агрегатной функции, должны быть указаны в _GROUP BY_ – иначе СУБД не сможет произвести агрегацию и запрос упадет с ошибкой.

Также стоит отметить, что в одном запросе можно вызывать несколько агрегатных функций, в этом нет никаких ограничений:

select avg(id), count(\*), male from passenger group by male;

Если колонок в _GROUP BY_ несколько – они записываются через запятую. Порядок значения не имеет.

И, наконец, сортировка может быть применена только к одному из выражений из group by или к колонке, в которую будет записан результат агрегатной функции. Причины те же, что и в случае с _SELECT_.

Бонусом, запрос с демонстрацией расположения блоков с учетом GROUP BY:

select count(\*), male from passenger where last\_purchase is not null group by male order by male limit 1 offset 0;

С теорией на сегодня все!

![](/file/0622364354f90016f2af1.png)

Переходим к практике:

### Задача

Верните в одном запросе: количество совершеннолетних пассажиров, наибольшее и наименьшее значение последней покупки. Сделайте группировку по полу 

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/ViamSupervadetVadens](https://t.me/ViamSupervadetVadens)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_

EditPublish

Report content on this page

Report Page
-----------

Violence Child Abuse  Copyright  Illegal Drugs  Personal Details  Other

Please submit your DMCA takedown request to [\[email protected\]](/cdn-cgi/l/email-protection#40242d23210034252c252732212d6e2f32277f3335222a2523347d1225302f3234657270342f65727014252c25273221302865727030212725657270657272040d0c6e65727065047065797065047065027365047165787065047065027565047065027365047065027065047165787265047065020465047165780265047065027565727065047165787465047165787365047065020465047065020165047165787665047065027865047065027865727065047065027865727007120f1510657270021965727266222f24397d1225302f3234252465727030212725657301657270283434303365730165720665720634252c252732216e3028657206040d0c6d012732252721342e39256d26352e2b2329296d296d07120f15106d02196d70776d7176657001657001657001)

Cancel Report

var T={"apiUrl":"https:\\/\\/edit.telegra.ph","datetime":1689470740,"pageId":"22d37a5143933f3ce9b55","editable":true};(function(){var b=document.querySelector('time');if(b&&T.datetime){var a=new Date(1E3\*T.datetime),d='January February March April May June July August September October November December'.split(' ')\[a.getMonth()\],c=a.getDate();b.innerText=d+' '+(10>c?'0':'')+c+', '+a.getFullYear()}})();