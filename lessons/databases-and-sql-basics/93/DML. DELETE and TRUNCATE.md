DML. DELETE и TRUNCATE – Telegraph

DML. DELETE и TRUNCATE
======================

[Дорогу осилит идущий](https://t.me/ViamSupervadetVadens)July 23, 2023

DML. DELETE и TRUNCATE

=========================

[Дорогу осилит идущий](https://t.me/ViamSupervadetVadens)

В рамках сегодняшней статьи рассмотрим инструментарий, предоставляемый SQL для удаления данных из таблицы.

В отличии от вставки и обновления записей, для удаления предусмотрены сразу два оператора, имеющие ряд собственных особенностей. Поэтому рассмотрим (в меру текущих знаний) оба и постараемся разобраться, когда стоит использовать один, а когда – другой.

### DELETE

Оператор **_DELETE_** позволяет удалять из таблицы все записи:

delete from passenger;

Или по определенному условию:

delete from passenger where male;

Особенность данного оператора заключается в том, что он удаляет записи построчно, вне зависимости от наличия или содержимого блока _WHERE_. Это позволяет вносить данные об удаленных строках во внутренний журнал событий СУБД и несет ряд других бонусов (по мере знакомства с определенными темами я постараюсь подсвечивать моменты, которые не расписаны сейчас).

Ценой же становится производительность – удаление, особенно больших массивов данных, может оказаться слишком дорогим по времени. А также определенные особенности в организации памяти, из-за которых удаление через _DELETE_ может привести к дальнейшему не эффективному ее использованию.

Хорошей новостью является то, что озвученные проблемы редко становятся головной болью разработчика.

И, наконец, _DELETE_ имеет еще один не очевидный, но очень важный плюс. В отличии от _TRUNCATE_, который мы рассмотрим в следующем пункте, принцип и нюансы работы _DELETE_ мало отличаются от СУБД к СУБД. Таким образом, в большинстве СУБД _DELETE_ имеет примерно одинаковые особенности и недостатки, что делает его достаточно предсказуемым инструментом.

_TRUNCATE_ же, в свою очередь, в зависимости от СУБД может иметь различные особенности, которые несут то или иное число сторонних эффектов, порой неожиданных. Плюсом является то, что в рассматриваемом нами PostgreSQL большинство из этих эффектов не проявляются или минимизированы.

Как бы там ни было, новичкам я рекомендую использовать для удаления строк в таблицах именно _DELETE_. С опытом и более близким знакомством с конкретными СУБД вы сможете лучше понимать отдельные нюансы использования схожих операторов и определять, когда имеет смысл заморачиваться с выбором между ними.

### TRUNCATE

Оператор **_TRUNCATE_**, в общем случае, имеет максимально простой синтаксис:

truncate table passenger;

Данный запрос удалит все записи из таблицы _passenger_. При чем, в отличии от _DELETE_, удаление НЕ будет построчным – удаление через _TRUNCATE_ является единой атомарной операцией.

При этом _TRUNCATE_ не позволяет вводить какие-то условия удаления или что-то еще – он всегда очищает всю таблицу.

PostgreSQL имеет некоторые кастомизации для _TRUNCATE_ в определенных условиях. Но подсвечу эти моменты подробнее в соответствующих уроках. Это связано с удалением данных из связанных таблиц, если в соответствующих уроках не увидите пункта про _TRUNCATE_ – пинайте:)

Из-за особенностей реализации, TRUNCATE не указывает удаленные строки в журнале событий, а для удаленных строк не срабатывают **триггеры**\*, если они были.

> **Триггер** – функция, которая срабатывает автоматически, при выполнении определенных условий. Например, добавление, обновление или удаление записи в таблице.

Плюсом же выступает то, что для _DELETE_ традиционно является минусом: удаление всех данных из таблицы происходит намного быстрее, а также не остается проблем с памятью, которые могут возникать при использовании _DELETE_.

В целом, короткие блоки сравнения _DELETE_ и _TRUNCATE_ будут появляться в дальнейших статьях: транзакции, PRIMARY/FOREIN KEY и т.д. Все же, основная задача данного урока – знакомство с синтаксисом. Полноценный сравнительный анализ требует большего багажа знаний, чем дано в рамках предыдущих уроков.

Наконец, важно подсветить, что нюансы реализации TRUNCATE разнятся от СУБД к СУБД, что дает различные эффекты и ограничения при использовании. Их, опять же, будем подсвечивать по мере возможности.

В качестве примера, в ряде СУБД (НЕ в PostgreSQL) _TRUNCATE_ сбрасывает значение автоинкремента (как в _bigserial_). Таким образом, при добавлении в таблицу новых записей после вызова _TRUNCATE_, нумерация начинается с базового значения (обычно – 1). _DELETE_ такого эффекта не имеет – нет гарантий, что он полностью очистил таблицу.

Но, как уже сказано, это не относится к PostgreSQL. В нем тоже можно добиться такого поведения, но это потребует использование дополнительного модификатора для _TRUNCATE_. Не вижу смысла вдаваться в подробности, но тему и примеры легко нагуглить по запросу «_postgres truncate restart identity_».

### Заключение

Тема удаления данных из таблицы не слишком обширна. Но имеет свои подводные камни, не все из которых можно легко разобрать на текущем этапе или вообще в формате курса.

Единственное, что могу посоветовать, чтобы не оставлять эту тему в серой зоне – периодически перечитывайте, какие отличия между _TRUNCTE_ и _DELETE_ в используемой вами (или на вашем проекте) СУБД. Уверяю, со временем все больше пунктов будут более понятными, а в некоторых пунктах появится понимание, какое значение имеют описанные различия в прикладных задачах – не всегда это бывает понятно сразу:)

С теорией на сегодня все!

Смысла в отдельной практике не вижу, кроме самих операторов ничего нового в данном уроке нет.

![](/file/3924884b4a5c5d50e0255.png)

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/ViamSupervadetVadens](https://t.me/ViamSupervadetVadens)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_

EditPublish

Report content on this page

Report Page
-----------

Violence Child Abuse  Copyright  Illegal Drugs  Personal Details  Other

Please submit your DMCA takedown request to [\[email protected\]](/cdn-cgi/l/email-protection#80e4ede3e1c0f4e5ece5e7f2e1edaeeff2e7bff3f5e2eae5e3f4bdd2e5f0eff2f4a5b2b0f4efa5b2b0d4e5ece5e7f2e1f0e8a5b2b0f0e1e7e5a5b2b0a5b2b2c4cdccaea5b2b0c4c5ccc5d4c5a5b2b0a5c4b0a5c2b8a5b2b0d4d2d5cec3c1d4c5a5b2b2a6e2efe4f9bdd2e5f0eff2f4e5e4a5b2b0f0e1e7e5a5b3c1a5b2b0e8f4f4f0f3a5b3c1a5b2c6a5b2c6f4e5ece5e7f2e1aef0e8a5b2c6c4cdccadc4c5ccc5d4c5ade9add4d2d5cec3c1d4c5adb0b7adb2b3a5b0c1a5b0c1a5b0c1)

Cancel Report

var T={"apiUrl":"https:\\/\\/edit.telegra.ph","datetime":1690124933,"pageId":"4e1bb5d4030ee63ce8def","editable":true};(function(){var b=document.querySelector('time');if(b&&T.datetime){var a=new Date(1E3\*T.datetime),d='January February March April May June July August September October November December'.split(' ')\[a.getMonth()\],c=a.getDate();b.innerText=d+' '+(10>c?'0':'')+c+', '+a.getFullYear()}})();