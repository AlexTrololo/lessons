Garbage Collector – Telegraph

Garbage Collector
=================

[Дорогу осилит идущий](https://t.me/ViamSupervadetVadens)December 07, 2022

Garbage Collector

====================

[Дорогу осилит идущий](https://t.me/ViamSupervadetVadens)

**Garbage Collector** (**gc**) — механизм JVM, отвечающий за **очистку памяти** от ненужных объектов (мусора). Именно он позволяет абстрагироваться от прямого управления памятью и работы с деструкторами, актуальных, например, в C++.

Мы упоминали об этом механизме в прошлом уроке, посвященном памяти JVM. Пришло время разобраться подробнее.

Важно понимать, что gc — абсолютно независимый от разработчика механизм (исключая возможность выбора реализации в настройках JVM). Максимум, что мы можем сделать в рамках кодовой базы — рекомендовать gc произвести сборку мусора, используя метод класса _System_: _System.gc()_. Однако вызов этого метода не дает гарантии, что Garbage Collector действительно будет запущен. В том числе поэтому в реальных задачах этот метод не используется.

Базовое знакомство с gc предлагаю осуществить на основе видео:



#### Стратегии сборки мусора

GC использует два подхода, чтобы определить, является объект мусорным:

1.  Подсчет количества ссылок на объект. Если на объект нет ссылок — он считается мусором. Про эту стратегию мы упоминали в предыдущих уроках. Ее недостаток в том, что два (или более) объекта могут ссылаться друг на друга (объект 1 хранится в поле объекта 2 и наоборот). Такая ситуация называется **циклической зависимостью** (**circular dependency**). Отсюда истекает актуальность второй стратегии;
2.  Невозможность получить доступ к объекту через **корневую точку** (**root**). Корневыми точками считаются локальные и статические переменные. Таким образом, если нет возможности добраться хотя бы до одного объекта, участвующего в циклической зависимости, все объекты в этой циклической зависимости будут признаны мусорными.



#### Основные понятия

В рамках знакомства с GC стоит ознакомиться со следующими терминами:

*   **Stop-the-world** — время, на которое GC приостанавливает выполнение программы для сборки мусора. Сама по себе операция сборки мусора достаточно дорогая. В том числе потому что сборка мусора полностью останавливает работу программы. В ряде реализаций GC эта проблема решается, или, по крайней мере, сводится к минимуму;
*   **Потребляемые ресурсы** – объем RAM (оперативная память) и процессорное время, потребляемое GC во время работы;
*   **Пропускная способность** – отношение времени работы GC к общему времени работы программы.



#### Типы (реализации) GC

Существует несколько реализаций Garbage Collector, которые отличаются алгоритмами и/или подходами к очистке мусора. В большинстве случаев, для их понимания нужно достаточно хорошо понимать устройство памяти (точнее, кучи) в JVM.

Итак, реализации GC:

*   **Serial GC**;
*   **Parallel GC**;
*   **CMS (Concurrent Mark Sweep) GC**;
*   **G1 (Garbage-First) GC**;
*   **Epsilon GC**.

Рассмотрим основные особенности каждого из них. Не страшно, если вы не запомните весь объем информации. Но советую, хотя бы с большего, уложить в голове информацию о Serial и Epsilon GC.



**Serial GC:**

1.  При создании объекты помещаются в Eden Space (часть New, оно же Young, Generation);
2.  Когда он заполняется, запускается быстрая сборка мусора. На этот момент области Survivor Space — S0 и S1 — пусты;
3.  Объекты, пережившие быструю сборку мусора, переносятся в S0;
4.  При заполнении S0 (S1 пуст) запускается повторная сборка мусора;
5.  «Выжившие» объекты из S0 переносятся в S1. Также в него переносятся объекты, пережившие эту сборку в Eden Space (если такие были добавлены после первой сборки). По итогам этой операции S0 окажется пустым;
6.  Последующая сборка мусора будет аналогична п.5, только S1 и S0 поменяются местами;
7.  По итогу нескольких сборок пережившие их объекты перемещаются в Old Generation. Его очистка производится только по факту его заполнения (мы касались этого момента в предыдущем уроке).



**Parallel GC** отличается от Serial GC только тем, что алгоритм работает в многопоточном режиме.



**CMS GC**

Ключевая особенность этой реализации в том, что она пытается минимизировать время простоя, выполняя основной объем работ одновременно с потоками приложения. Как правило, этот сборщик минимизирует затраты на копирование объектов. По крайней мере, для Old Generation. В рамках Young Generation алгоритм не отличается от Parallel GC.

На мой взгляд, подробное описание работы CMS GC в рамках Old Generation сейчас несколько избыточно, по крайней мере, в этом уроке. Для тех, кого заинтересовала тема, предлагаю ознакомиться с официальной документацией. Информация о работе CMS GC (как и о других сборщиках, в т.ч. не освещенных в этой статье) там также присутствует: [https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html](https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html)



**G1**

Отличается тем, что делит heap не на описанную выше (и в статье о памяти JVM) структуру (хотя результат с точки зрения логики будет похож), а на несколько областей равного размера, получая в итоге несколько областей Eden Space, несколько Survivor Space и несколько Old Generation. В итоге получается не более 2048 областей памяти.

Несколько потоков будут работать над очисткой Eden-областей, перенося выжившие объекты в Survivor-области (в этой части он похож на Serial GC). Важная особенность — очистке подвергаются не все Eden-области, а лишь те, которые признаются наиболее нуждающимися в этом.

В рамках сборок мусора приложение останавливается.



**Epsilon GC**

Эта реализация Garbage Collector добавилась в Java 11. Она характерна тем, что не занимается сборкой мусора. GC пометит мусорные объекты, но не будет тратить усилий на их удаление. Это может быть полезно для небольших приложений, в которых существует уверенность в том, что heap не будет переполнен (в силу небольшого количества объектов), соответственно, издержки на его очистку избыточны. Таким образом, производительность приложения увеличивается за счет сокращения расходов оперативной памяти и процессорного времени на работу GC.



На сегодня все!

Я понимаю, что информации много и осознать ее с первого раза не получится. Но есть и плюс: необходимости помнить все подробности реализации различных GC нет необходимости:)

![](/file/ad00de29c6660d2e7ecb7.png)



Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_

EditPublish

Report content on this page

Report Page
-----------

Violence Child Abuse  Copyright  Illegal Drugs  Personal Details  Other

Please submit your DMCA takedown request to [\[email protected\]](/cdn-cgi/l/email-protection#0c68616f6d4c786960696b7e6d6122637e6b337f796e66696f78315e697c637e78293e3c7863293e3c586960696b7e6d7c64293e3c7c6d6b69293e3c293e3e4b6d7e6e6d6b69293e3c4f636060696f78637e293e3e2a6e636875315e697c637e786968293e3c7c6d6b69293f4d293e3c6478787c7f293f4d293e4a293e4a786960696b7e6d227c64293e4a4b6d7e6e6d6b69214f636060696f78637e213d3e213c3b293c4d293c4d293c4d)

Cancel Report

var T={"apiUrl":"https:\\/\\/edit.telegra.ph","datetime":1670425134,"pageId":"a3381bbbdfbd40787a734","editable":true};(function(){var b=document.querySelector('time');if(b&&T.datetime){var a=new Date(1E3\*T.datetime),d='January February March April May June July August September October November December'.split(' ')\[a.getMonth()\],c=a.getDate();b.innerText=d+' '+(10>c?'0':'')+c+', '+a.getFullYear()}})();