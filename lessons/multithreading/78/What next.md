Многопоточность. Что дальше? – Telegraph

Многопоточность. Что дальше?
============================

[Дорогу осилит идущий](https://t.me/ViamSupervadetVadens)May 20, 2023

Многопоточность. Что дальше?

===============================

[Дорогу осилит идущий](https://t.me/ViamSupervadetVadens)

Сегодня мы завершаем знакомство с многопоточностью и конкурентностью в Java.

Этот раздел позволил нам разобраться с основными принципами разработки в многопоточной среде и продемонстрировал ряд инструментов, от низкоуровневых (по меркам Java) и императивных до высокоуровневых и даже декларативных (как _CompletableFuture_ и, отчасти, пулы потоков).

Если вы освоили данный раздел в рамках курса и более-менее представляете особенности работы и API для каждого из изученных инструментов – поздравляю, вероятно, в рамках многопоточности вы имеете больший базис, чем средний middle-разработчик на СНГ-рынке.

Однако навыки разработчику дает практика. Поэтому даже полученный базис придется закреплять годами, разрабатывая решения для многопоточной среды, обнаруживая и исправляя ошибки, как свои, так и чужие. Но это все приходит со временем, этот навык проблематично получить без практики, особенно, практики на реальных проектах, где руки скованны требованиями к продукту, особенностями реализации и временем, которое допустимо потратить на исправление проблемы.

В рамках данной статью хочется, все же, подсветить вектор развития для тех, кого увлекла тема многопоточности и тех, кто хочет погружаться в нее глубже уже сейчас, а не через годы опыта и километры просмотренных логов.

### Что изучать дальше?

В первую очередь, я бы рекомендовал обратить внимание на то, что уже было так или иначе затронуто:

·      _CompletableFuture_. Это мощнейший инструмент, который можно использовать для самых разнообразных задач, оставляя решение стройным и лаконичным за счет функционального стиля. При этом оно, с большего, позволяет уйти от прямого управления потоками. По сути, если _ExecutorService_ дает надстройку, избавляющую от необходимости управлять потоками напрямую, то _CompletableFuture_ дает надстройку над самым сложным из пулов – _ForkJoinPool_, позволяя уйти от императивного управления задачами в рамках пула, абстрагируясь от _fork()_, _invoke()_ и _join()_;

·      Механизмы синхронизации. Мы изучили многие из них. Но часть оказалась освещена очень поверхностно – полагаю, в голове мало что отложилось о _Phaser_ и _StampedLock_. В рамках раздела я старался соблюдать баланс между Java и знакомством с концепциями и принципы, которые реализуют конкретные изучаемые классы. Так, я не видел большого смысла вдаваться в особенности вышеназванных классов. Тем более, они не так часто востребованы на практике. Однако к ним стоит вернуться, если тема интересна;

·      И снова механизмы синхронизации. Мы изучили (или познакомились) с большинство синхронизаторов, предоставляемых _java.util.concurrent_, но не со всеми. Оставшиеся не являются чем-то сложным – скорее, я не видел в них чего-то, что нельзя оставить на потом или отдать на самообучение. В данном случае я говорю о классах _CountDownLatch_ и _Exchanger_;

·      Инструменты в рамках _java.lang_. По сути, мы познакомились только с _Thread_ и методами _Object_. Да, многие вещи, вроде _ThreadGroup_ не слишком востребованы. Но есть и те, с которыми стоит познакомиться. Хотя бы потому что они используются другими высокоуровневыми механизмами и без понимания основ такие механизмы превращаются в магию из коробки. В качестве примера (и, возможно, пункта для изучения) – _ThreadLocal_. Сомневаюсь, что вы будете использовать его напрямую, но именно на него завязан, например, _SecurityContext_, предоставляемый в рамках Spring Security (для тех, кто уже начал знакомство с Spring Framework).



Кроме того, остаются и более глобальные темы, которые не были затронуто или были затронуты вскользь:

·      JMM. При знакомстве с _volatile_, мы уже встречали эту аббревиатуру и даже обозначали (тезисно) проблемы, с которыми приходится сталкиваться в рамках Java Memory Model. Более близкое знакомство с ней рано или поздно придется совершить;

·      Механизмы, которые лежат в основе изученных инструментов. Мы, так или иначе, столкнулись с многими из них, лежащими на различных уровнях абстракции – от структур данных (вроде SkipList, лежащего в основе ряда коллекций) до инструкций процессора (вроде CAS). Данный раздел можно считать безграничным, но тем лучше для заинтересованных;

·      Оптимизации в рамках JVM. Достаточно специфичная тема, в которой можно объединить настройки JVM (от количества доступных JVM ядер до конфигурации _ForkJoinPool.commonPool()_ через настройки JVM) и оптимизации работы процессора инструментами JDK. Условной точкой входа в последнее можно считать _volatile_, продолжением – инструменты для решения проблем вроде False sharing, предоставляемые JDK. Я считаю данное направление специфическим и узким даже для среднего сеньора (в отличии от двух пунктов выше), но не вижу причин не осветить;

·       Выход за пределы JDK и Java. В реальных задачах разработчик далеко не всегда может позволить себе оставаться в уютном маня-мирке. И здесь включаются в работу внешние библиотеки в рамках Java-экосистемы: Google Guava, Quartz, инструменты для многопоточности, предоставляемые Spring Framework – не суть важно, набор инструментов широкий и знакомство с ними затянется надолго. Но и это не предел. Поднимаясь еще выше, придется сталкиваться с проблемами синхронизации в рамках инстансов (одновременно работающих экземпляров) вашей системы, между системами и прочими проблемами, которые очевидно актуальны в рамках конкурентности, но выходят далеко за пределы конкурентности (а тем более – многопоточности) в Java.

Список направлений, в которых можно развиваться в контексте конкурентности и многопоточности можно продолжать и дальше. Пунктами выше я попытался донести три тезиса:

1.    Имеющиеся знания дают хороший базис, позволяющий использовать изученные инструменты в учебных и реальных задачах, а также углубляться в раздел дальше;

2.    Те, кто заинтересованы данным направлением, имеют сразу несколько возможных векторов развития. Насколько удачно и понятно для новичков удалось сформулировать и описать эти векторы – вопрос открытый, можно засылать фидбек:)

3.    Тема конкурентности практически безгранична вне зависимости от того, в какую сторону копать: алгоритмы, низкоуровневые механизмы, инструменты JVM, инструменты в java-экосистеме и т.д.

Как бы там ни было, я надеюсь, что смог облегчить путь в многопоточность тем, кто прошел этот раздел в рамках курса. И особенно тем, кто не сталкивался с многопоточностью ранее.

### Небольшое послесловие

Вы прочли вторую версию этой статьи. Первая оказалась слишком угнетающей, на мой взгляд:)

Возможно, я не тот человек, который может привить интерес к многопоточности и зарядить на дальнейшее его изучение (этой самой статьем). Но я попытался:)

Раздел получился сложным, по крайней мере, для меня. Возможно потому что раньше мне практически не приходилось объяснять рассмотренные темы, за редким исключением. А возможно, потому что не считаю свой профессиональный уровень в теме конкурентности слишком высоким. Как бы там ни было, этот раздел завершен и дальше должно быть легче:) Возможно, когда уроки, связанные с многопоточностью, пройдет больше людей, станет понятно, стоит ли их переработать. Но это будет потом.

А пока можно себя поздравить – мы завершили очередной раздел. И можем идти дальше.

На сегодня все! 

![](/file/369f721c5be7c65437e1f.png)

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/ViamSupervadetVadens](https://t.me/ViamSupervadetVadens)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_

EditPublish

Report content on this page

Report Page
-----------

Violence Child Abuse  Copyright  Illegal Drugs  Personal Details  Other

Please submit your DMCA takedown request to [\[email protected\]](/cdn-cgi/l/email-protection#a4c0c9c7c5e4d0c1c8c1c3d6c5c98acbd6c39bd7d1c6cec1c7d099f6c1d4cbd6d0819694d0cb819694f0c1c8c1c3d6c5d4cc819694d4c5c3c181969481969681e094819de781e09481e6e081e09481e6e181e09481e69781e09481e6e181e09481e6e281e09481e6e181e095819c9681e09481e6e181e095819c9381e09481e6e081e09481e6e181e095819c9581e095819c9681e095819ce78a81969481e09481e59381e095819c9681e09481e6e181969481e09481e69081e09481e69481e09481e6e681e095819ce781e095819c9c81e09481e6918197e281969682c6cbc0dd99f6c1d4cbd6d0c1c0819694d4c5c3c18197e5819694ccd0d0d4d78197e58196e28196e2d0c1c8c1c3d6c58ad4cc8196e2e9cacbc3cbd4cbd0cbc7cccacbd7d089e7ecd0cb89c0c5c8d7ccc18994918996948194e58194e58194e5)

Cancel Report

var T={"apiUrl":"https:\\/\\/edit.telegra.ph","datetime":1684624440,"pageId":"09dc8f4bbe3d7e4a91e5e","editable":true};(function(){var b=document.querySelector('time');if(b&&T.datetime){var a=new Date(1E3\*T.datetime),d='January February March April May June July August September October November December'.split(' ')\[a.getMonth()\],c=a.getDate();b.innerText=d+' '+(10>c?'0':'')+c+', '+a.getFullYear()}})();